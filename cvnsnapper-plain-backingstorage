#!/bin/bash
#
# cvnsnapper-plain-backingstorage - btrfs backing storage
# Copyright (C) 2017  Fabian Pietsch <fabian@canvon.de>

warn() {
	echo "${0##*/}: $*" >&2
}

die() {
	warn "Fatal: $*"
	exit 1
}


get-dev-parents() {
	[ "$#" -eq 1 ] || die "Internal error: get-device-parents needs exactly one argument, the device path"
	local DEV="$1"
	shift

	local DID_IT=0 DEV_STAT_LINE=
	DEV_STAT_LINE=$(stat -L -c "0x%t 0x%T %F" "$DEV") && DID_IT=1
	if [ "$DID_IT" -eq 0 ] || [ -z "$DEV_STAT_LINE" ]
	then
		warn "Warning: get-device-parents can't get stat information for device path \"$DEV\""
		return 1
	fi

	if ! read DEV_MAJOR_HEX DEV_MINOR_HEX DEV_FILE_TYPE <<<"$DEV_STAT_LINE"
	then
		warn "Warning: get-device-parents can't interpret stat information \"$DEV_STAT_LINE\" for device path \"$DEV\""
		return 1
	fi

	DEV_TYPE=
	case "$DEV_FILE_TYPE" in
	"block special file")
		DEV_TYPE=b
		;;
	"character special file")
		DEV_TYPE=c
		;;
	"regular file")
		DEV_TYPE=f
		;;
	*)
		warn "Warning: get-device-parents was given a non-device \"$DEV\" of file type \"$DEV_FILE_TYPE\""
		return 1
		;;
	esac

	[ -n "$DEV_TYPE" ] || die "Internal error: get-device-parents couldn't determine device type for device path \"$DEV\""

	case "$[DEV_MAJOR_HEX],$[DEV_MINOR_HEX],$DEV_TYPE" in
	*,*,f)
		# Regular file -- search ends here.
		# TODO: Continue with the containing file system ...
		warn "Warning: get-device-parents got to a regular file, \"$DEV\", but won't recurse into file systems, yet"
		echo DEV_TYPE "regular file"
		return 0
		;;
	8,*,b)
		# SCSI (or, today, about any type of) disk -- search ends here.
		local OUT_DEV_TYPE="SCSI-alike disk"
		local DISK_INDEX="$[DEV_MINOR_HEX / 16]" PART_NR="$[DEV_MINOR_HEX % 16]"
		local DISK_ALPHA="$(perl -le "print(chr(ord('a') + $DISK_INDEX))")"
		if [ "$PART_NR" -eq 0 ]
		then
			OUT_DEV_TYPE="$OUT_DEV_TYPE, disk index $DISK_INDEX aka alpha $DISK_ALPHA (whole disk sd$DISK_ALPHA)"
		else
			OUT_DEV_TYPE="$OUT_DEV_TYPE, disk index $DISK_INDEX aka alpha $DISK_ALPHA, partition $PART_NR (sd$DISK_ALPHA$PART_NR)"
		fi
		echo DEV_TYPE "$OUT_DEV_TYPE"
		return 0
		;;
	254,*,b)
		# device mapper (DM)
		echo DEV_TYPE "device mapper (DM, major:minor $DEV_MAJOR_HEX:$DEV_MINOR_HEX)"

		local FAILED=0 DEV_PARENTS_LINE= DEV_PARENTS=
		DEV_PARENTS_LINE=$(dmsetup deps -o devname "$DEV") || FAILED=1
		DEV_PARENTS=$(sed -n -e 's#^[0-9]\+ dependencies\t:##; s#^ \+(\([^)]*\))#\1\n#mgp' <<<"$DEV_PARENTS_LINE") || FAILED=1
		if [ "$FAILED" -ne 0 ]
		then
			warn "Error: get-device-parents couldn't determine device-mapper dependencies of device path \"$DEV\""
			return 1
		fi

		local PARENT
		for PARENT in $DEV_PARENTS
		do
			if [ -e /dev/mapper/"$PARENT" ]
			then
				echo PARENT /dev/mapper/"$PARENT"
			elif [ -e /dev/"$PARENT" ]
			then
				echo PARENT /dev/"$PARENT"
			else
				# This will result in error later, but don't just omit a parent.
				echo PARENT "$PARENT"
			fi
		done

		return 0
		;;
	*,*,b)
		# Fallback -- search ends here, for now. User has to see
		# for himself whether this device type has any backing storage
		# of its own.
		echo DEV_TYPE "unknown block special (major:minor $DEV_MAJOR_HEX:$DEV_MINOR_HEX)"
		return 0
		;;
	*)
		warn "Warning: get-device-parents does not know how to determine backing storage of device path \"$DEV\" (dev type \"$DEV_TYPE\", major:minor $DEV_MAJOR_HEX:$DEV_MINOR_HEX)"
		return 1
		;;
	esac

	return 0
}

recurse-dev-parents() {
	local INDENT="$1"; shift
	local DEV
	for DEV
	do
		local DID_IT=0 DEV_PARENTS_LINES=
		DEV_PARENTS_LINES=$(get-dev-parents "$DEV") && DID_IT=1
		if [ "$DID_IT" -eq 0 ]
		then
			echo "$INDENT$DEV: Can't determine parents, will stop recursing here."
			continue
		fi

		local NUM_KEYS=0 DEV_PARENTS=()
		while read KEY VALUE
		do
			case "$KEY" in
			"")
				# Try to ignore empty lines.
				[ -z "$VALUE" ] || die "Internal error: get-dev-parents returned empty key with value \"$VALUE\""
				continue
				;;
			DEV_TYPE)
				echo "$INDENT$DEV: $VALUE"
				;;
			PARENT)
				DEV_PARENTS=("${DEV_PARENTS[@]}" "$VALUE")
				;;
			*)
				die "Internal error: get-dev-parents returned unrecognized key \"$KEY\" for device path \"$DEV\""
				;;
			esac
			: $[NUM_KEYS++]
		done <<<"$DEV_PARENTS_LINES"

		[ "$NUM_KEYS" -gt 0 ] || die "Internal error: get-dev-parents gave no useable output for device path \"$DEV\""

		[ "${#DEV_PARENTS[*]}" -gt 0 ] && recurse-dev-parents "$INDENT    " "${DEV_PARENTS[@]}"
	done

	return 0
}


USAGE="cvnsnapper-plain-backingstorage show BTRFS_MOUNT_POINT"

while [ "$#" -gt 0 ] && [ "${1:0:1}" = "-" ]
do
	OPTION="$1"
	shift

	case "$OPTION" in
	--help|--usage|-\?)
		echo "Usage: $USAGE"
		exit 0
		;;
	*)
		die "Invalid option \"$OPTION\""
		;;
	esac
done

[ "$#" -ge 1 ] || die "Usage: $USAGE"

MODE="$1"
shift

case "$MODE" in
show)
	[ "$#" -eq 1 ] || die "Mode-of-operation \"$MODE\" takes exactly one argument, the btrfs mount point to operate on"

	BTRFS_MOUNT_POINT="$1"
	shift

	DID_IT=0
	BTRFS_FI_SHOW=$(btrfs filesystem show "$BTRFS_MOUNT_POINT") && DID_IT=1
	if [ "$DID_IT" -eq 0 ] || [ -z "$BTRFS_FI_SHOW" ]
	then
		die "Getting basic filesystem information via \"btrfs\" command failed"
	fi

	BTRFS_DEVICES=()
	while read TOKEN1 TOKEN2 REST
	do
		case "$TOKEN1" in
		Label:|uuid:)
			# Ignore, for now.
			;;
		Total)
			# Ignore, for now.
			;;
		devid)
			# Bingo!
			DID_IT=0
			BTRFS_CUR_DEV_PATH=$(sed -n -e 's#^.*path \([^ ]*\)\( .*\)*$#\1#p' <<<"$REST") && DID_IT=1
			if [ "$DID_IT" -eq 0 ] || [ -z "$BTRFS_CUR_DEV_PATH" ]
			then
				die "Couldn't extract device path from $TOKEN1 $TOKEN2"  # Usually: devid N
			fi
			BTRFS_DEVICES=("${BTRFS_DEVICES[@]}" "$BTRFS_CUR_DEV_PATH")
			;;
		"")
			# Ignore empty line.
			;;
		Btrfs)
			# Ignore version information, for now.
			;;
		*)
			warn "Warning: Unrecognized line starting with token \"$TOKEN1\", ignoring"
			;;
		esac
	done <<<"$BTRFS_FI_SHOW"

	echo "Found ${#BTRFS_DEVICES[*]} devices: ${BTRFS_DEVICES[*]}"

	recurse-dev-parents "" "${BTRFS_DEVICES[@]}"

	exit
	;;
*)
	die "Invalid mode-of-operation \"$MODE\""
	;;
esac

exit 0
