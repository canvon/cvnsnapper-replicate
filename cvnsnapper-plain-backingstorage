#!/bin/bash
#
# cvnsnapper-plain-backingstorage - examine file-system/device backing storage
# Copyright (C) 2017  Fabian Pietsch <fabian@canvon.de>

#
# General helper functions
#

warn() {
	echo "${0##*/}: $*" >&2
}

die() {
	warn "Fatal: $*"
	exit 1
}


#
# Convert between size in bytes and size in units, and back
#

size-to-unit() {
	[ "$#" -eq 2 ] || die "Internal error: size-to-unit needs exactly two arguments, the size and the unit"
	local SIZE="$1"; shift
	local UNIT="$1"; shift
	perl -le "
		use strict;
		use warnings;
		my \$size = \"$SIZE\";
		my \$unit = \"$UNIT\";
		my %unit_to_factor = (
			TiB => 1024**4, GiB => 1024**3, MiB => 1024**2, KiB => 1024**1,
			TB  => 1000**4, GB  => 1000**3, MB  => 1000**2, KB  => 1000**1,
			B   => 1
		);
		die(\"Internal error: size-to-unit got request for unrecognized unit \\\"\$unit\\\"\")
		  unless exists(\$unit_to_factor{\$unit});
		my \$factor = \$unit_to_factor{\$unit};
		if (\$factor == 1) {
			print(\"\$size \$unit\");
		}
		else {
			my \$size_unit = \$size / \$factor;
			printf('%.2f %s', \$size_unit, \$unit);
		}
	"
}

size-to-some-unit() {
	local SI=0 BOTH=0 SEPARATOR=", "
	while [ "$#" -gt 0 ] && [ "${1:0:1}" = "-" ]
	do
		local OPTION="$1"
		shift

		case "$OPTION" in
		--si)
			SI=1
			BOTH=0
			;;
		--iec)
			SI=0
			BOTH=0
			;;
		--both)
			BOTH=1
			;;
		--separator=*)
			SEPARATOR="${OPTION#--separator=}"
			;;
		*)
			die "Internal error: size-to-some-unit got invalid option \"$OPTION\""
			;;
		esac
	done

	[ "$#" -eq 1 ] || die "Internal error: size-to-some-unit takes exactly one non-option argument, the size to convert"

	local SIZE="$1"
	shift

	local SI_UNITS="TB GB MB KB B"
	local IEC_UNITS="TiB GiB MiB KiB B"
	local OUR_UNITS=
	if [ "$SI" -eq 1 ] && [ "$BOTH" -eq 0 ]
	then
		OUR_UNITS="$SI_UNITS"
	else
		OUR_UNITS="$IEC_UNITS"
	fi

	local UNIT UNIT_SIZE
	for UNIT in $OUR_UNITS
	do
		local DID_IT=0
		UNIT_SIZE_STR=$(size-to-unit "$SIZE" "$UNIT") && DID_IT=1
		if [ "$DID_IT" -eq 0 ]
		then
			warn "Warning: size-to-some-unit: size-to-unit failed for size \"$SIZE\", unit \"$UNIT\""
			continue
		fi

		local UNIT_SIZE DUMMY
		read UNIT_SIZE DUMMY <<<"$UNIT_SIZE_STR"
		perl -e "\"$UNIT_SIZE\" >= 1.0 && exit(0); exit(1);" || continue

		if [ "$UNIT" = "B" ]
		then
			echo "$UNIT_SIZE_STR"
		else
			if [ "$BOTH" -eq 0 ]
			then
				echo "$UNIT_SIZE_STR"
			else
				# Try to be sure to have same order of magnitude for both values.
				# (Otherwise, there could be "1 TB, 1000 GiB"
				# which should rather read "1073 GB, 1000 GiB".)
				echo "$(size-to-unit "$SIZE" "${UNIT:0:1}B")$SEPARATOR$UNIT_SIZE_STR"
			fi
		fi
		return 0
	done

	echo "$SIZE B"
	return 0
}

unit-to-size() {
	[ "$#" -eq 1 ] || die "Internal error: unit-to-size needs exactly one argument, the unit to convert to size-in-bytes"
	local UNIT="$1"; shift
	# Use Perl to cope with floating point numbers,
	# and for regex flexibility.
	perl -le '
		use strict;
		use warnings;
		my $input = <>;
		chomp($input); 
		$input =~ /^\s*([0-9]+(?:\.[0-9]+))\s*(B|[KGT]iB|[KGT]B)\s*$/
		  or die("Error: unit-to-size: Cannot parse size + unit\n");
		my ($size_unit, $unit) = ($1, $2);
		if ($unit eq "B") { print($size_unit); }
		elsif ($unit eq "KiB") { print($size_unit * 1024**1); }
		elsif ($unit eq "MiB") { print($size_unit * 1024**2); }
		elsif ($unit eq "GiB") { print($size_unit * 1024**3); }
		elsif ($unit eq "TiB") { print($size_unit * 1024**4); }
		elsif ($unit eq "KB") { print($size_unit * 1000**1); }
		elsif ($unit eq "MB") { print($size_unit * 1000**2); }
		elsif ($unit eq "GB") { print($size_unit * 1000**3); }
		elsif ($unit eq "TB") { print($size_unit * 1000**4); }
		else { die("Error: unit-to-size: Unsupported unit \"$unit\""); }
		exit(0);
	' <<<"$UNIT"
}


#
# Per-file-system type helpers
#

get-zfs-parents() {
	[ "$#" -eq 1 ] || die "Internal error: get-zfs-parents needs exactly one argument, the mount point or device path"

	local ZFS="$1"
	shift

	local ZPOOL=$(echo "$ZFS" | sed 's/\/.*//;s/@.*//;')

	local SIZE=$(zfs get -pH used "$ZFS" | cut -f3)
	local SIZE_ZPOOL=$(zpool get -pH size "$ZPOOL" | cut -f3)

	local DID_IT=0 ZPOOL_STATUS=
	ZPOOL_STATUS=$(zpool status -P "$ZPOOL") && DID_IT=1
	if [ "$DID_IT" -eq 0 ] || [ -z "$ZPOOL_STATUS" ]
	then
		warn "Error: get-zfs-parents couldn't get pool status via \"zpool\" command for pool \"$ZPOOL\" that contains \"$ZFS\""
		return 1
	fi

	local POOL_DEVICES=$(echo "$ZPOOL_STATUS" | sed -n 's/\s\+/\t/g;s/^\s\+//;/NAME.\+STATE.\+READ.\+WRITE.\+CKSUM/,$p' | cut -f1 | grep ^/ | sed 's/^/PARENT /')

	if [ -z "$POOL_DEVICES" ]
	then
		warn "Error: get-zfs-parents could not determine any parent devices for pool \"$ZPOOL\" that contains \"$ZFS\""
		return 1
	fi

	echo "SIZE zpool=$ZPOOL $SIZE_ZPOOL"
	echo "SIZE zfs=$ZFS $SIZE zpool=$SIZE_ZPOOL"
	echo "$POOL_DEVICES"

	return 0
}

get-btrfs-parents() {
	[ "$#" -eq 1 ] || die "Internal error: get-btrfs-parents needs exactly one argument, the mount point or device path"

	local BTRFS="$1"
	shift

	local DID_IT=0 BTRFS_FI_SHOW=
	BTRFS_FI_SHOW=$(btrfs filesystem show "$BTRFS") && DID_IT=1
	if [ "$DID_IT" -eq 0 ] || [ -z "$BTRFS_FI_SHOW" ]
	then
		warn "Error: get-btrfs-parents couldn't get basic filesystem information via \"btrfs\" command for \"$BTRFS\""
		return 1
	fi

	local BTRFS_DEVICES=()
	local BTRFS_DEV_COUNT= BTRFS_DEV_SEEN=
	local TOKEN1 TOKEN2 REST
	while read TOKEN1 TOKEN2 REST
	do
		case "$TOKEN1" in
		Label:|uuid:)
			# Ignore, for now.
			;;
		Total)
			[ -z "$BTRFS_DEV_COUNT" ] || warn "Warning: get-btrfs-parents already got btrfs device count! Previous value was \"$BTRFS_DEV_COUNT\""
			local DID_IT=0
			BTRFS_DEV_COUNT=$(sed -n -e 's#^Total devices \([0-9]\+\)\( .*\)*$#\1#p' <<<"$TOKEN1 $TOKEN2 $REST") && DID_IT=1
			if [ "$DID_IT" -eq 0 ] || [ -z "$BTRFS_DEV_COUNT" ]
			then
				warn "Warning: get-btrfs-parents can't get btrfs device count"
			fi
			;;
		devid)
			# Bingo!

			local BTRFS_CUR_DEV_ID="$TOKEN2"  # (Hope this won't break too soon. :-S)
			if [ -n "$BTRFS_DEV_COUNT" ] && [ "$BTRFS_CUR_DEV_ID" -gt "$BTRFS_DEV_COUNT" ]
			then
				warn "Warning: get-btrfs-parents sees devid \"$BTRFS_CUR_DEV_ID\" greater than total device count \"$BTRFS_DEV_COUNT\"; please check"
			fi
			if grep -q -E "\\b$BTRFS_CUR_DEV_ID\\b" <<<"$BTRFS_DEV_SEEN"
			then
				warn "Warning: get-btrfs-parents already seen devid \"$BTRFS_CUR_DEV_ID\"; please check"
			fi
			BTRFS_DEV_SEEN="$BTRFS_DEV_SEEN $BTRFS_CUR_DEV_ID"

			local DID_IT=0 BTRFS_CUR_DEV_PATH=
			BTRFS_CUR_DEV_PATH=$(sed -n -e 's#^.*path \([^ ]*\)\( .*\)*$#\1#p' <<<"$REST") && DID_IT=1
			if [ "$DID_IT" -eq 0 ] || [ -z "$BTRFS_CUR_DEV_PATH" ]
			then
				warn "Error: get-btrfs-parents couldn't extract device path from $TOKEN1 $TOKEN2"  # Usually: devid N
				return 1
			fi
			BTRFS_DEVICES=("${BTRFS_DEVICES[@]}" "$BTRFS_CUR_DEV_PATH")

			local DID_IT=0 BTRFS_CUR_DEV_SIZE=
			BTRFS_CUR_DEV_SIZE=$(sed -n -e 's#^.*size \([^ ]*\)\( .*\)*$#\1#p' <<<"$REST") && DID_IT=1
			if [ "$DID_IT" -eq 0 ] || [ -z "$BTRFS_CUR_DEV_SIZE" ]
			then
				warn "Error: get-btrfs-parents couldn't extract device size from $TOKEN1 $TOKEN2"  # Usually: devid N
				return 1
			fi
			echo SIZE "devid=$BTRFS_CUR_DEV_ID,path=$BTRFS_CUR_DEV_PATH" "$(unit-to-size "$BTRFS_CUR_DEV_SIZE")" ${FS_SIZE:+file-system=$FS_SIZE}
			;;
		"")
			# Ignore empty line.
			;;
		Btrfs)
			# Ignore version information, for now.
			;;
		*)
			warn "Warning: get-btrfs-parents got unrecognized line starting with token \"$TOKEN1\", ignoring"
			;;
		esac
	done <<<"$BTRFS_FI_SHOW"

	if [ "${#BTRFS_DEVICES[*]}" -lt 1 ]
	then
		warn "Error: get-btrfs-parents could not determine any parent devices for btrfs at \"$DEV\""
		return 1
	fi

	if [ "${#BTRFS_DEVICES[*]}" -ne "$BTRFS_DEV_COUNT" ]
	then
		warn "Warning: get-btrfs-parents got more/fewer devices (${#BTRFS_DEVICES[*]}) than what was announced as total device count ($BTRFS_DEV_COUNT) before; please check"
		warn "Continuing, to give a chance of successful use even during time of breakage (e.g., bad disk)"
	fi

	for PARENT in "${BTRFS_DEVICES[@]}"
	do
		echo PARENT "$PARENT"
	done

	return 0
}


#
# Get file-system/device parents
#

get-device-parents-fs() {
	# File or directory; use df to get at parent device!
	local DEV_MOUNT_POINT="$DEV"
	local LOOP_COUNTER=0 FS_TYPE= FS_SOURCE= FS_TARGET= FS_SIZE=
	while [ "$[++LOOP_COUNTER]" -eq 1 ] || { [ "$FS_TYPE" = "-" ] && [ "$FS_SOURCE" = "-" ]; }
	do
		# (Arbitrary limit, but it can't be helped. (?)
		# Else we risk an endless loop.)
		if [ "$LOOP_COUNTER" -gt 50 ]
		then
			warn "Error: get-device-parents can't determine filesystem mount point for \"$DEV\", giving up at try $LOOP_COUNTER with last candidate mount point \"$DEV_MOUNT_POINT\" (result \"$FS_TARGET\")"
			return 1
		fi

		if [ "$LOOP_COUNTER" -gt 1 ]
		then
			# If it's a non-directory (e.g., a file), strip off file name
			# to get to something that has ".." (parent directory).
			[ -d "$DEV_MOUNT_POINT" ] || DEV_MOUNT_POINT="${DEV_MOUNT_POINT%/*}"

			# Next try: Parent directory.
			DEV_MOUNT_POINT="$DEV_MOUNT_POINT/.."
		fi

		local DID_IT=0 FS_TYPE_LINES=
		FS_TYPE_LINES="$(df --output=fstype,source,target,size --block-size=1 "$DEV_MOUNT_POINT")" && DID_IT=1
		if [ "$DID_IT" -eq 0 ] || [ -z "$FS_TYPE_LINES" ]
		then
			warn "Error: get-device-parents can't determine filesystem type (df failed) for mount point candidate \"$DEV_MOUNT_POINT\" for \"$DEV\""
			return 1
		fi
		local DUMMY
		read FS_TYPE FS_SOURCE FS_TARGET FS_SIZE DUMMY < <(tail -n +2 <<<"$FS_TYPE_LINES")
		if [ -z "$FS_TYPE" ]
		then
			warn "Error: get-device-parents can't determine filesystem type (can't parse df output) for mount point candidate \"$DEV_MOUNT_POINT\" for \"$DEV\""
			return 1
		fi
	done
	if [ "$FS_TYPE" = "-" ]
	then
		warn "Error: get-device-parents can't determine filesystem type (df doesn't know) for mount point candidate \"$DEV_MOUNT_POINT\" for \"$DEV\""
		return 1
	fi

	local DEV_TYPE_INFO="$DEV_FILE_TYPE"
	[ "$VERBOSE" -ge 1 ] && DEV_TYPE_INFO="$DEV_TYPE_INFO on filesystem type \"$FS_TYPE\" mounted from \"$FS_SOURCE\" on mount point \"$FS_TARGET\""
	echo DEV_TYPE "$DEV_TYPE_INFO"

	if [ "$DEV_TYPE" = "f" ]
	then
		local FILE_SIZE
		local DID_IT=0
		FILE_SIZE=$(stat -c "%s" "$DEV") && DID_IT=1
		if [ "$DID_IT" -eq 0 ] || [ -z "$FILE_SIZE" ]
		then
			warn "Warning: get-device-parents can't determine file \"$DEV\"'s size, omitting"
		else
			echo SIZE file "$FILE_SIZE"
		fi
	fi
	echo SIZE file-system "$FS_SIZE"

	case "$FS_TYPE" in
	btrfs)
		case "$FS_TARGET" in
		""|"-"|"none")
			warn "Error: get-device-parents can't determine filesystem mount point (df doesn't know at end of recursion) for \"$DEV\", but need to know for \"btrfs filesystem show\" call"
			return 1
			;;
		esac

		get-btrfs-parents "$FS_TARGET"
		return
		;;
	zfs)
		case "$FS_TARGET" in
		""|"-"|"none")
			warn "Error: get-device-parents can't determine filesystem mount point (df doesn't know at end of recursion) for \"$DEV\", but need to know for ZFS \"zpool status\" call"
			return 1
			;;
		esac

		get-zfs-parents "$FS_SOURCE"
		return
		;;
	*)
		case "$FS_SOURCE" in
		""|"-"|"none")
			warn "Error: Recursing on a directory and/or mount point, but mount source seems to be unknown to df. Can't determine parent device!"
			return 1
			;;
		esac

		echo PARENT "$FS_SOURCE"
		return 0
		;;
	esac
}

get-device-parents-scsidisk() {
	# SCSI (or, today, about any type of) disk
	local OUT_DEV_TYPE="SCSI-alike disk"
	local DISK_INDEX="$[DEV_MINOR / 16]" PART_NR="$[DEV_MINOR % 16]"
	local DISK_ALPHA="$(perl -le "print(chr(ord('a') + $DISK_INDEX))")"
	local DISK_MNEMONIC="sd$DISK_ALPHA" DISK_SUB_MNEMONIC=
	if [ "$PART_NR" -eq 0 ]
	then
		DISK_SUB_MNEMONIC="$DISK_MNEMONIC"
		[ "$VERBOSE" -ge 1 ] && OUT_DEV_TYPE="$OUT_DEV_TYPE, disk index $DISK_INDEX aka alpha $DISK_ALPHA (whole disk $DISK_SUB_MNEMONIC)"
	else
		DISK_SUB_MNEMONIC="$DISK_MNEMONIC$PART_NR"
		[ "$VERBOSE" -ge 1 ] && OUT_DEV_TYPE="$OUT_DEV_TYPE, disk index $DISK_INDEX aka alpha $DISK_ALPHA, partition $PART_NR ($DISK_SUB_MNEMONIC)"
	fi
	echo DEV_TYPE "$OUT_DEV_TYPE"

	local DID_IT= SIZE=
	# Additionally, determine size of "holding" device;
	# that is, of which full hard disk this is a partition.
	local HOLDING_SIZE=
	if [ "$DISK_SUB_MNEMONIC" != "$DISK_MNEMONIC" ]
	then
		local DISK_MNEMONIC_PATH="/dev/$DISK_MNEMONIC"
		if ! [ -b "$DISK_MNEMONIC_PATH" ]
		then
			warn "Warning: get-device-parents can't determine size of holding device as \"$DISK_MNEMONIC_PATH\" does not exist or is not a block special device"
		else
			DID_IT=0
			HOLDING_SIZE=$(blockdev --getsize64 "$DISK_MNEMONIC_PATH") && DID_IT=1
			if [ "$DID_IT" -eq 0 ] || [ -z "$HOLDING_SIZE" ]
			then
				[ "$VERBOSE" -gt -1 ] && warn "Warning: get-device-parents can't determine size of holding device \"$DISK_MNEMONIC_PATH\" in bytes (command blockdev failed)"
				HOLDING_SIZE=
			fi
		fi
	fi
	DID_IT=0
	SIZE=$(blockdev --getsize64 "$DEV") && DID_IT=1
	if [ "$DID_IT" -eq 0 ] || [ -z "$SIZE" ]
	then
		[ "$VERBOSE" -gt -1 ] && warn "Warning: get-device-parents can't determine size of device \"$DEV\" in bytes (command blockdev failed)"
		SIZE=
	else
		echo SIZE block_device "$SIZE" ${HOLDING_SIZE:+holding_device=$HOLDING_SIZE}
	fi
	[ -n "$HOLDING_SIZE" ] && echo SIZE holding_device "$HOLDING_SIZE"

	return 0
}

get-device-parents-loop() {
	# loop device
	local DEV_TYPE_INFO="loop device"
	[ "$VERBOSE" -ge 1 ] && DEV_TYPE_INFO="$DEV_TYPE_INFO, index $DEV_MINOR (loop$DEV_MINOR)"
	echo DEV_TYPE "$DEV_TYPE_INFO"

	local DID_IT=0 SIZE=
	SIZE=$(blockdev --getsize64 "$DEV") && DID_IT=1
	if [ "$DID_IT" -eq 0 ] || [ -z "$SIZE" ]
	then
		[ "$VERBOSE" -gt -1 ] && warn "Warning: get-device-parents can't determine size of device \"$DEV\" in bytes (command blockdev failed)"
	else
		echo SIZE block_device "$SIZE"
	fi

	local DID_IT=0 LOOP_LINES=
	LOOP_LINES=$(losetup --list --noheadings --output=back-file "$DEV") && DID_IT=1
	if [ "$DID_IT" -eq 0 ] || [ -z "$LOOP_LINES" ]
	then
		warn "Error: get-device-parents couldn't determine loop backing-file of device path \"$DEV\""
		return 1
	fi

	echo PARENT "$LOOP_LINES"

	return 0
}

get-device-parents-md() {
	# md-raid (multiple-device RAID)

	local DID_IT=0 MD_LINES=
	MD_LINES=$(mdadm --query --detail --export "$DEV") && DID_IT=1
	if [ "$DID_IT" -eq 0 ] || [ -z "$MD_LINES" ]
	then
		warn "Error: get-device-parents couldn't determine md-raid details of device path \"$DEV\""
		return 1
	fi

	local MD_NAME=
	MD_NAME=$(grep '^MD_NAME=' <<<"$MD_LINES" | sed -n -e 's#^MD_NAME=##p') || MD_NAME=

	local DEV_TYPE_INFO="md-raid"
	if [ "$VERBOSE" -ge 1 ]
	then
		DEV_TYPE_INFO="$DEV_TYPE_INFO (multiple-disks${MD_NAME:+, name $MD_NAME}, major:minor $DEV_MAJOR:$DEV_MINOR)"
	else
		DEV_TYPE_INFO="$DEV_TYPE_INFO${MD_NAME:+, name $MD_NAME}"
	fi
	echo DEV_TYPE "$DEV_TYPE_INFO"

	local DID_IT=0 SIZE=
	SIZE=$(blockdev --getsize64 "$DEV") && DID_IT=1
	if [ "$DID_IT" -eq 0 ] || [ -z "$SIZE" ]
	then
		[ "$VERBOSE" -gt -1 ] && warn "Warning: get-device-parents can't determine size of device \"$DEV\" in bytes (command blockdev failed)"
	else
		echo SIZE block_device "$SIZE"
	fi

	local MD_LEVEL= MD_LAST_ROLE= MD_LAST_DEV= MD_AVAIL_DEV_SIZE_SEEN=0
	local KEY VALUE
	while IFS="=" read KEY VALUE
	do
		case "$KEY" in
		MD_LEVEL)
			MD_LEVEL="$VALUE"
			;;
		MD_DEVICE_*_ROLE)
			MD_LAST_ROLE="$VALUE"
			;;
		MD_DEVICE_*_DEV)
			MD_LAST_DEV="$VALUE"

			if [ "$MD_AVAIL_DEV_SIZE_SEEN" -eq 0 ]
			then
				local MD_LAST_SIZE_MDADM=
				MD_LAST_SIZE_MDADM=$(mdadm --query --examine "$MD_LAST_DEV" | sed -n -e 's#^ *Avail \+Dev \+Size \+: \+\([0-9]\+\) .*$#\1#p') || MD_LAST_SIZE_MDADM=
				if [ -n "$MD_LAST_SIZE_MDADM" ]
				then
					local MD_LAST_SIZE="$[MD_LAST_SIZE_MDADM * 1024]"
					echo SIZE "level=$MD_LEVEL,avail_devices_size" "$MD_LAST_SIZE" ${SIZE:+block_device=$SIZE}
					MD_AVAIL_DEV_SIZE_SEEN=1
				fi
			fi
			local MD_LAST_SIZE=
			MD_LAST_SIZE=$(blockdev --getsize64 "$MD_LAST_DEV") || MD_LAST_SIZE=
			[ -n "$MD_LAST_SIZE" ] && [ "$VERBOSE" -ge 1 ] && echo SIZE "level=$MD_LEVEL,role=$MD_LAST_ROLE,dev=$MD_LAST_DEV" "$MD_LAST_SIZE" ${SIZE:+block_device=$SIZE}

			echo PARENT "$VALUE"
			;;
		*)
			# Ignore, for now.
			;;
		esac
	done <<<"$MD_LINES"

	return 0
}

get-device-parents-dm() {
	# device-mapper (DM)
	local DM_NAME=
	DM_NAME=$(dmsetup info --columns --noheadings -o name -j "$DEV_MAJOR" -m "$DEV_MINOR") || DM_NAME=
	local DEV_TYPE_INFO="device-mapper"
	if [ "$VERBOSE" -ge 1 ]
	then
		DEV_TYPE_INFO="$DEV_TYPE_INFO (DM${DM_NAME:+, name $DM_NAME}, major:minor $DEV_MAJOR:$DEV_MINOR)"
	else
		DEV_TYPE_INFO="$DEV_TYPE_INFO${DM_NAME:+, name $DM_NAME}"
	fi
	echo DEV_TYPE "$DEV_TYPE_INFO"

	local DID_IT=0 SIZE=
	SIZE=$(blockdev --getsize64 "$DEV") && DID_IT=1
	if [ "$DID_IT" -eq 0 ] || [ -z "$SIZE" ]
	then
		[ "$VERBOSE" -gt -1 ] && warn "Warning: get-device-parents can't determine size of device \"$DEV\" in bytes (command blockdev failed)"
	else
		echo SIZE block_device "$SIZE"
	fi

	local DID_IT=0 DEV_TARGETS_SUBCMD="status" DEV_TARGETS_LINES=
	[ "$VERBOSE" -ge 1 ] && DEV_TARGETS_SUBCMD="table"
	DEV_TARGETS_LINES=$(dmsetup "$DEV_TARGETS_SUBCMD" "$DEV") && DID_IT=1
	if [ "$DID_IT" -eq 0 ] || [ -z "$DEV_TARGETS_LINES" ]
	then
		warn "Warning: get-device-parents couldn't get list of targets for device \"$DEV\", ignoring"
	else
		local START LEN_512 TARGET DUMMY
		while read START LEN_512 TARGET DUMMY
		do
			[ -z "$START" ] && continue
			local DM_INFO="target=$TARGET"
			case "$TARGET" in
			linear)
				local LINEAR_DEV LINEAR_OFFSET DUMMY2
				read LINEAR_DEV LINEAR_OFFSET DUMMY2 <<<"$DUMMY"
				if [ -n "$LINEAR_DEV" ]
				then
					DM_INFO="$DM_INFO,dev=$LINEAR_DEV"
					[ -n "$LINEAR_OFFSET" ] && DM_INFO="$DM_INFO,offset=$LINEAR_OFFSET"
				fi
				;;
			crypt)
				local CRYPT_CIPHER CRYPT_KEY CRYPT_DUMMY1 CRYPT_DEV CRYPT_OFFSET DUMMY2
				read CRYPT_CIPHER CRYPT_KEY CRYPT_DUMMY1 CRYPT_DEV CRYPT_OFFSET DUMMY2 <<<"$DUMMY"
				[ -n "$CRYPT_CIPHER" ] && DM_INFO="$DM_INFO,cipher=$CRYPT_CIPHER"
				if [ -n "$CRYPT_DEV" ]
				then
					DM_INFO="$DM_INFO,dev=$CRYPT_DEV"
					[ -n "$CRYPT_OFFSET" ] && DM_INFO="$DM_INFO,offset=$CRYPT_OFFSET"
				fi
				;;
			*)
				DM_INFO="$DM_INFO,target_is_unknown"
				;;
			esac
			echo SIZE "$DM_INFO" "$[LEN_512 * 512]" ${SIZE:+block_device=$SIZE}
		done <<<"$DEV_TARGETS_LINES"
	fi

	local FAILED=0 DEV_PARENTS_LINE= DEV_PARENTS=
	DEV_PARENTS_LINE=$(dmsetup deps -o devname "$DEV") || FAILED=1
	DEV_PARENTS=$(sed -n -e 's#^[0-9]\+ dependencies\t:##; s#^ \+(\([^)]*\))#\1\n#mgp' <<<"$DEV_PARENTS_LINE") || FAILED=1
	if [ "$FAILED" -ne 0 ]
	then
		warn "Error: get-device-parents couldn't determine device-mapper dependencies of device path \"$DEV\""
		return 1
	fi

	local PARENT
	for PARENT in $DEV_PARENTS
	do
		if [ -e /dev/mapper/"$PARENT" ]
		then
			echo PARENT /dev/mapper/"$PARENT"
		elif [ -e /dev/"$PARENT" ]
		then
			echo PARENT /dev/"$PARENT"
		else
			# This will result in error later, but don't just omit a parent.
			echo PARENT "$PARENT"
		fi
	done

	return 0
}

get-device-parents-generalblockdev() {
	# general block special device
	echo DEV_TYPE "unknown block special (major:minor $DEV_MAJOR:$DEV_MINOR)"

	local DID_IT=0 SIZE=
	SIZE=$(blockdev --getsize64 "$DEV") && DID_IT=1
	if [ "$DID_IT" -eq 0 ] || [ -z "$SIZE" ]
	then
		[ "$VERBOSE" -gt -1 ] && warn "Warning: get-device-parents can't determine size of device \"$DEV\" in bytes (command blockdev failed)"
	else
		echo SIZE block_device "$SIZE"
	fi

	return 0
}

get-device-parents() {
	[ "$#" -eq 1 ] || die "Internal error: get-device-parents needs exactly one argument, the device path"
	local DEV="$1"
	shift

	local DID_IT=0 DEV_STAT_LINE=
	DEV_STAT_LINE=$(stat -L -c "0x%t 0x%T %F" "$DEV") && DID_IT=1
	if [ "$DID_IT" -eq 0 ] || [ -z "$DEV_STAT_LINE" ]
	then
		warn "Warning: get-device-parents can't get stat information for device path \"$DEV\""
		return 1
	fi

	if ! read DEV_MAJOR_HEX DEV_MINOR_HEX DEV_FILE_TYPE <<<"$DEV_STAT_LINE"
	then
		warn "Warning: get-device-parents can't interpret stat information \"$DEV_STAT_LINE\" for device path \"$DEV\""
		return 1
	fi

	DEV_TYPE=
	case "$DEV_FILE_TYPE" in
	"block special file")
		DEV_TYPE=b
		;;
	"character special file")
		DEV_TYPE=c
		;;
	"directory")
		DEV_TYPE=d
		;;
	"regular file")
		DEV_TYPE=f
		;;
	*)
		warn "Warning: get-device-parents was given a non-device \"$DEV\" of file type \"$DEV_FILE_TYPE\""
		return 1
		;;
	esac

	[ -n "$DEV_TYPE" ] || die "Internal error: get-device-parents couldn't determine device type for device path \"$DEV\""

	local DEV_MAJOR=
	if [ -n "$DEV_MAJOR_HEX" ]
	then
		DEV_MAJOR="$[DEV_MAJOR_HEX]"
		[ -n "$DEV_MAJOR" ] || warn "Internal error: Converting hex \"$DEV_MAJOR_HEX\" to decimal failed"
	fi
	[ -n "$DEV_MAJOR" ] || DEV_MAJOR="unknown"

	local DEV_MINOR=
	if [ -n "$DEV_MINOR_HEX" ]
	then
		DEV_MINOR="$[DEV_MINOR_HEX]"
		[ -n "$DEV_MINOR" ] || warn "Internal error: Converting hex \"$DEV_MINOR_HEX\" to decimal failed"
	fi
	[ -n "$DEV_MINOR" ] || DEV_MINOR="unknown"

	case "$DEV_MAJOR,$DEV_MINOR,$DEV_TYPE" in
	*,*,[fd])
		# File or directory
		get-device-parents-fs
		return
		;;
	8,*,b)
		# SCSI (or, today, about any type of) disk -- search ends here.
		get-device-parents-scsidisk
		return
		;;
	7,*,b)
		# loop device
		get-device-parents-loop
		return
		;;
	9,*,b)
		# md-raid (multiple-device RAID)
		get-device-parents-md
		return
		;;
	24[0-9],*,b|25[0-4],*,b)  # block major 240-254, "local/experimental use" inside of "reserved for dynamic assignment"
		local SYS_DEV_SYMLINK="/sys/dev/block/$DEV_MAJOR:$DEV_MINOR"
		if [ -L "$SYS_DEV_SYMLINK" ]
		then
			local DID_IT=0 SYS_DEV_SYMLINK_TARGET=
			SYS_DEV_SYMLINK_TARGET=$(readlink "$SYS_DEV_SYMLINK") && DID_IT=1
			if [ "$DID_IT" -eq 0 ] || [ -z "$SYS_DEV_SYMLINK_TARGET" ]
			then
				# TODO: Additionally invoke general block special handler?
				warn "Warning: get-device-parents can't determine what block special major:minor $DEV_MAJOR:$DEV_MINOR is used for (readlink failed on \"$SYS_DEV_SYMLINK\")"
				return 1
			fi

			case "$SYS_DEV_SYMLINK_TARGET" in
			../../devices/virtual/block/dm-*)
				: # device-mapper for sure; just continue
				;;
			*)
				# TODO: Additionally invoke general block special handler?
				warn "Warning: get-device-parents can't determine what block special major:minor $DEV_MAJOR:$DEV_MINOR is used for (unrecognized symlink target \"$SYS_DEV_SYMLINK_TARGET\" from \"$SYS_DEV_SYMLINK\")"
				return 1
				;;
			esac
		else
			: # Simply assume device-mapper, for now. ...
			warn "Warning: Assuming block major:minor $DEV_MAJOR:$DEV_MINOR is used for device-mapper; this may well be wrong!"
		fi

		# device-mapper (DM)
		get-device-parents-dm
		return
		;;
	*,*,b)
		# Fallback -- search ends here, for now. User has to see
		# for himself whether this device type has any backing storage
		# of its own.
		get-device-parents-generalblockdev
		return
		;;
	*)
		warn "Warning: get-device-parents does not know how to determine backing storage of device path \"$DEV\" (dev type \"$DEV_TYPE\", major:minor $DEV_MAJOR:$DEV_MINOR)"
		return 1
		;;
	esac

	return 0
}


#
# Handle recursion, and generate output while doing so
#

recurse-device-parents() {
	[ "$#" -ge 1 ] || die "Internal error: recurse-device-parents needs at least one argument, the indentation"
	local INDENT="$1"; shift
	local DEV
	for DEV
	do
		[ "$VERBOSE" -ge 2 ] && echo "$INDENT$DEV:"

		local DID_IT=0 DEV_PARENTS_LINES=
		DEV_PARENTS_LINES=$(get-device-parents "$DEV") && DID_IT=1
		if [ "$DID_IT" -eq 0 ]
		then
			if [ "$VERBOSE" -ge 2 ]
			then
				echo "$INDENT* Can't determine parents, will stop recursing here."
			elif [ "$VERBOSE" -le -1 ]
			then
				echo "$INDENT$DEV (parents missing)"
			else
				echo "$INDENT$DEV: Can't determine parents, will stop recursing here."
			fi
			continue
		fi

		local NUM_KEYS=0 NUM_DEV_TYPE=0 DEV_PARENTS=()
		while read KEY VALUE
		do
			case "$KEY" in
			"")
				# Try to ignore empty lines.
				[ -z "$VALUE" ] || die "Internal error: get-device-parents returned empty key with value \"$VALUE\""
				continue
				;;
			DEV_TYPE)
				: $[NUM_DEV_TYPE++]

				if [ "$VERBOSE" -ge 2 ]
				then
					echo "$INDENT* Type: $VALUE"
				elif [ "$VERBOSE" -le -1 ]
				then
					echo "$INDENT$DEV"
				else
					echo "$INDENT$DEV: $VALUE"
				fi
				;;
			PARENT)
				DEV_PARENTS=("${DEV_PARENTS[@]}" "$VALUE")
				;;
			SIZE)
				local SIZE_TYPE SIZE_VALUE SIZE_REF DUMMY
				read SIZE_TYPE SIZE_VALUE SIZE_REF DUMMY <<<"$VALUE"

				local SIZE_REF_NAME= SIZE_REF_VALUE= SIZE_PERCENT=
				if [ -n "$SIZE_REF" ]
				then
					if grep -q '=' <<<"$SIZE_REF"
					then
						SIZE_REF_NAME="${SIZE_REF%%=*}"
						SIZE_REF_VALUE="${SIZE_REF#*=}"
					else
						SIZE_REF_VALUE="$SIZE_REF"
					fi
					[ "$VERBOSE" -ge 1 ] && SIZE_PERCENT=$(perl -le "printf('%6.2f%%', 100.0 * $SIZE_VALUE / $SIZE_REF_VALUE)")
				fi

				if [ "$VERBOSE" -ge 2 ]
				then
					echo "$INDENT* Size of $SIZE_TYPE: $SIZE_VALUE B ($(size-to-some-unit --both "$SIZE_VALUE")${SIZE_PERCENT:+, $SIZE_PERCENT${SIZE_REF_NAME:+ of $SIZE_REF_NAME}})"
				elif [ "$VERBOSE" -le -1 ]
				then
					: # Nothing.
				else
					echo "$INDENT  $SIZE_TYPE: $(size-to-some-unit --both --separator=" / " "$SIZE_VALUE")${SIZE_PERCENT:+ ($SIZE_PERCENT${SIZE_REF_NAME:+ of $SIZE_REF_NAME})}"
				fi
				;;
			*)
				die "Internal error: get-device-parents returned unrecognized key \"$KEY\" for device path \"$DEV\""
				;;
			esac
			: $[NUM_KEYS++]
		done <<<"$DEV_PARENTS_LINES"

		[ "$NUM_KEYS" -gt 0 ] || die "Internal error: get-device-parents gave no useable output for device path \"$DEV\""

		[ "$NUM_DEV_TYPE" -gt 0 ] || die "Internal error: get-device-parents omitted the DEV_TYPE key for device path \"$DEV\""

		if [ "$VERBOSE" -ge 2 ]
		then
			if [ "${#DEV_PARENTS[*]}" -gt 0 ]
			then
				echo "$INDENT* Found ${#DEV_PARENTS[*]} parent devices: ${DEV_PARENTS[*]}"
			else
				echo "$INDENT* Leaf device (no further parents), consider this the final backing storage."
			fi
		fi

		[ "${#DEV_PARENTS[*]}" -gt 0 ] && recurse-device-parents "$INDENT    " "${DEV_PARENTS[@]}"
	done

	return 0
}


#
# main -- parse command-line arguments and initiate recursion
#

VERBOSE=0

USAGE="cvnsnapper-plain-backingstorage show BTRFS_MOUNT_POINT"

while [ "$#" -gt 0 ] && [ "${1:0:1}" = "-" ]
do
	OPTION="$1"
	shift

	case "$OPTION" in
	--help|--usage|-\?)
		echo "Usage: $USAGE"
		exit 0
		;;
	-v)
		: $[VERBOSE++]
		;;
	-q)
		: $[VERBOSE--]
		;;
	*)
		die "Invalid option \"$OPTION\""
		;;
	esac
done

[ "$#" -ge 1 ] || die "Usage: $USAGE"

MODE="$1"
shift

case "$MODE" in
show)
	[ "$#" -eq 1 ] || die "Mode-of-operation \"$MODE\" takes exactly one argument, the mount point or block device to operate on"

	START_DEV="$1"
	shift

	recurse-device-parents "" "$START_DEV"

	exit
	;;
*)
	die "Invalid mode-of-operation \"$MODE\""
	;;
esac

exit 0
