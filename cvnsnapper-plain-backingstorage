#!/bin/bash
#
# cvnsnapper-plain-backingstorage - btrfs backing storage
# Copyright (C) 2017  Fabian Pietsch <fabian@canvon.de>

warn() {
	echo "${0##*/}: $*" >&2
}

die() {
	warn "Fatal: $*"
	exit 1
}


get-btrfs-parents() {
	[ "$#" -eq 1 ] || die "Internal error: get-btrfs-parents needs exactly one argument, the mount point or device path"

	local BTRFS="$1"
	shift

	local DID_IT=0 BTRFS_FI_SHOW=
	BTRFS_FI_SHOW=$(btrfs filesystem show "$BTRFS") && DID_IT=1
	if [ "$DID_IT" -eq 0 ] || [ -z "$BTRFS_FI_SHOW" ]
	then
		warn "Error: get-btrfs-parents couldn't get basic filesystem information via \"btrfs\" command for \"$BTRFS\""
		return 1
	fi

	local BTRFS_DEVICES=()
	local TOKEN1 TOKEN2 REST
	while read TOKEN1 TOKEN2 REST
	do
		case "$TOKEN1" in
		Label:|uuid:)
			# Ignore, for now.
			;;
		Total)
			# Ignore, for now.
			;;
		devid)
			# Bingo!
			local DID_IT=0 BTRFS_CUR_DEV_PATH=
			BTRFS_CUR_DEV_PATH=$(sed -n -e 's#^.*path \([^ ]*\)\( .*\)*$#\1#p' <<<"$REST") && DID_IT=1
			if [ "$DID_IT" -eq 0 ] || [ -z "$BTRFS_CUR_DEV_PATH" ]
			then
				warn "Error: get-btrfs-parents couldn't extract device path from $TOKEN1 $TOKEN2"  # Usually: devid N
				return 1
			fi
			BTRFS_DEVICES=("${BTRFS_DEVICES[@]}" "$BTRFS_CUR_DEV_PATH")
			;;
		"")
			# Ignore empty line.
			;;
		Btrfs)
			# Ignore version information, for now.
			;;
		*)
			warn "Warning: get-btrfs-parents got unrecognized line starting with token \"$TOKEN1\", ignoring"
			;;
		esac
	done <<<"$BTRFS_FI_SHOW"

	if [ "${#BTRFS_DEVICES[*]}" -lt 1 ]
	then
		warn "Error: get-btrfs-parents could not determine any parent devices for btrfs at \"$DEV\""
		return 1
	fi

	for PARENT in "${BTRFS_DEVICES[@]}"
	do
		echo PARENT "$PARENT"
	done

	return 0
}

get-device-parents() {
	[ "$#" -eq 1 ] || die "Internal error: get-device-parents needs exactly one argument, the device path"
	local DEV="$1"
	shift

	local DID_IT=0 DEV_STAT_LINE=
	DEV_STAT_LINE=$(stat -L -c "0x%t 0x%T %F" "$DEV") && DID_IT=1
	if [ "$DID_IT" -eq 0 ] || [ -z "$DEV_STAT_LINE" ]
	then
		warn "Warning: get-device-parents can't get stat information for device path \"$DEV\""
		return 1
	fi

	if ! read DEV_MAJOR_HEX DEV_MINOR_HEX DEV_FILE_TYPE <<<"$DEV_STAT_LINE"
	then
		warn "Warning: get-device-parents can't interpret stat information \"$DEV_STAT_LINE\" for device path \"$DEV\""
		return 1
	fi

	DEV_TYPE=
	case "$DEV_FILE_TYPE" in
	"block special file")
		DEV_TYPE=b
		;;
	"character special file")
		DEV_TYPE=c
		;;
	"directory")
		DEV_TYPE=d
		;;
	"regular file")
		DEV_TYPE=f
		;;
	*)
		warn "Warning: get-device-parents was given a non-device \"$DEV\" of file type \"$DEV_FILE_TYPE\""
		return 1
		;;
	esac

	[ -n "$DEV_TYPE" ] || die "Internal error: get-device-parents couldn't determine device type for device path \"$DEV\""

	local DEV_MAJOR=
	if [ -n "$DEV_MAJOR_HEX" ]
	then
		DEV_MAJOR="$[DEV_MAJOR_HEX]"
		[ -n "$DEV_MAJOR" ] || warn "Internal error: Converting hex \"$DEV_MAJOR_HEX\" to decimal failed"
	fi
	[ -n "$DEV_MAJOR" ] || DEV_MAJOR="unknown"

	local DEV_MINOR=
	if [ -n "$DEV_MINOR_HEX" ]
	then
		DEV_MINOR="$[DEV_MINOR_HEX]"
		[ -n "$DEV_MINOR" ] || warn "Internal error: Converting hex \"$DEV_MINOR_HEX\" to decimal failed"
	fi
	[ -n "$DEV_MINOR" ] || DEV_MINOR="unknown"

	case "$DEV_MAJOR,$DEV_MINOR,$DEV_TYPE" in
	*,*,[fd])
		# File or directory; use df to get at parent device!
		local DEV_MOUNT_POINT="$DEV"
		local LOOP_COUNTER=0 FS_TYPE= FS_SOURCE= FS_TARGET=
		while [ "$[++LOOP_COUNTER]" -eq 1 ] || { [ "$FS_TYPE" = "-" ] && [ "$FS_SOURCE" = "-" ]; }
		do
			# (Arbitrary limit, but it can't be helped. (?)
			# Else we risk an endless loop.)
			if [ "$LOOP_COUNTER" -gt 50 ]
			then
				warn "Error: get-device-parents can't determine filesystem mount point for \"$DEV\", giving up at try $LOOP_COUNTER with last candidate mount point \"$DEV_MOUNT_POINT\" (result \"$FS_TARGET\")"
				return 1
			fi

			if [ "$LOOP_COUNTER" -gt 1 ]
			then
				# If it's a non-directory (e.g., a file), strip off file name
				# to get to something that has ".." (parent directory).
				[ -d "$DEV_MOUNT_POINT" ] || DEV_MOUNT_POINT="${DEV_MOUNT_POINT%/*}"

				# Next try: Parent directory.
				DEV_MOUNT_POINT="$DEV_MOUNT_POINT/.."
			fi

			local DID_IT=0 FS_TYPE_LINES=
			FS_TYPE_LINES="$(df --output=fstype,source,target "$DEV_MOUNT_POINT")" && DID_IT=1
			if [ "$DID_IT" -eq 0 ] || [ -z "$FS_TYPE_LINES" ]
			then
				warn "Error: get-device-parents can't determine filesystem type (df failed) for mount point candidate \"$DEV_MOUNT_POINT\" for \"$DEV\""
				return 1
			fi
			local DUMMY
			read FS_TYPE FS_SOURCE FS_TARGET DUMMY < <(tail -n +2 <<<"$FS_TYPE_LINES")
			if [ -z "$FS_TYPE" ]
			then
				warn "Error: get-device-parents can't determine filesystem type (can't parse df output) for mount point candidate \"$DEV_MOUNT_POINT\" for \"$DEV\""
				return 1
			fi
		done
		if [ "$FS_TYPE" = "-" ]
		then
			warn "Error: get-device-parents can't determine filesystem type (df doesn't know) for mount point candidate \"$DEV_MOUNT_POINT\" for \"$DEV\""
			return 1
		fi

		echo DEV_TYPE "$DEV_FILE_TYPE on filesystem type \"$FS_TYPE\" mounted from \"$FS_SOURCE\" on mount point \"$FS_TARGET\""

		case "$FS_TYPE" in
		btrfs)
			case "$FS_TARGET" in
			""|"-"|"none")
				warn "Error: get-device-parents can't determine filesystem mount point (df doesn't know at end of recursion) for \"$DEV\", but need to know for \"btrfs filesystem show\" call"
				return 1
				;;
			esac

			get-btrfs-parents "$FS_TARGET"
			return
			;;
		*)
			case "$FS_SOURCE" in
			""|"-"|"none")
				warn "Error: Recursing on a directory and/or mount point, but mount source seems to be unknown to df. Can't determine parent device!"
				return 1
				;;
			esac

			echo PARENT "$FS_SOURCE"
			;;
		esac
		;;
	8,*,b)
		# SCSI (or, today, about any type of) disk -- search ends here.
		local OUT_DEV_TYPE="SCSI-alike disk"
		local DISK_INDEX="$[DEV_MINOR / 16]" PART_NR="$[DEV_MINOR % 16]"
		local DISK_ALPHA="$(perl -le "print(chr(ord('a') + $DISK_INDEX))")"
		if [ "$PART_NR" -eq 0 ]
		then
			OUT_DEV_TYPE="$OUT_DEV_TYPE, disk index $DISK_INDEX aka alpha $DISK_ALPHA (whole disk sd$DISK_ALPHA)"
		else
			OUT_DEV_TYPE="$OUT_DEV_TYPE, disk index $DISK_INDEX aka alpha $DISK_ALPHA, partition $PART_NR (sd$DISK_ALPHA$PART_NR)"
		fi
		echo DEV_TYPE "$OUT_DEV_TYPE"
		return 0
		;;
	7,*,b)
		# loop device
		echo DEV_TYPE "loop device, index $DEV_MINOR (loop$DEV_MINOR)"

		local DID_IT=0 LOOP_LINES=
		LOOP_LINES=$(losetup --list --noheadings --output=back-file "$DEV") && DID_IT=1
		if [ "$DID_IT" -eq 0 ] || [ -z "$LOOP_LINES" ]
		then
			warn "Error: get-device-parents couldn't determine loop backing-file of device path \"$DEV\""
			return 1
		fi

		echo PARENT "$LOOP_LINES"

		return 0
		;;
	9,*,b)
		# md-raid (multiple-device RAID)
		echo DEV_TYPE "md-raid (multiple-disks, major:minor $DEV_MAJOR:$DEV_MINOR)"

		local DID_IT=0 MD_LINES=
		MD_LINES=$(mdadm --query --detail --export "$DEV") && DID_IT=1
		if [ "$DID_IT" -eq 0 ] || [ -z "$MD_LINES" ]
		then
			warn "Error: get-device-parents couldn't determine md-raid details of device path \"$DEV\""
			return 1
		fi

		while IFS="=" read KEY VALUE
		do
			case "$KEY" in
			MD_DEVICE_*_DEV)
				echo PARENT "$VALUE"
				;;
			*)
				# Ignore, for now.
				;;
			esac
		done <<<"$MD_LINES"

		return 0
		;;
	254,*,b)
		# device-mapper (DM)
		echo DEV_TYPE "device-mapper (DM, major:minor $DEV_MAJOR:$DEV_MINOR)"

		local FAILED=0 DEV_PARENTS_LINE= DEV_PARENTS=
		DEV_PARENTS_LINE=$(dmsetup deps -o devname "$DEV") || FAILED=1
		DEV_PARENTS=$(sed -n -e 's#^[0-9]\+ dependencies\t:##; s#^ \+(\([^)]*\))#\1\n#mgp' <<<"$DEV_PARENTS_LINE") || FAILED=1
		if [ "$FAILED" -ne 0 ]
		then
			warn "Error: get-device-parents couldn't determine device-mapper dependencies of device path \"$DEV\""
			return 1
		fi

		local PARENT
		for PARENT in $DEV_PARENTS
		do
			if [ -e /dev/mapper/"$PARENT" ]
			then
				echo PARENT /dev/mapper/"$PARENT"
			elif [ -e /dev/"$PARENT" ]
			then
				echo PARENT /dev/"$PARENT"
			else
				# This will result in error later, but don't just omit a parent.
				echo PARENT "$PARENT"
			fi
		done

		return 0
		;;
	*,*,b)
		# Fallback -- search ends here, for now. User has to see
		# for himself whether this device type has any backing storage
		# of its own.
		echo DEV_TYPE "unknown block special (major:minor $DEV_MAJOR:$DEV_MINOR)"
		return 0
		;;
	*)
		warn "Warning: get-device-parents does not know how to determine backing storage of device path \"$DEV\" (dev type \"$DEV_TYPE\", major:minor $DEV_MAJOR:$DEV_MINOR)"
		return 1
		;;
	esac

	return 0
}

recurse-device-parents() {
	[ "$#" -ge 1 ] || die "Internal error: recurse-device-parents needs at least one argument, the indentation"
	local INDENT="$1"; shift
	local DEV
	for DEV
	do
		[ "$VERBOSE" -ge 1 ] && echo "$INDENT$DEV:"

		local DID_IT=0 DEV_PARENTS_LINES=
		DEV_PARENTS_LINES=$(get-device-parents "$DEV") && DID_IT=1
		if [ "$DID_IT" -eq 0 ]
		then
			if [ "$VERBOSE" -ge 1 ]
			then
				echo "$INDENT* Can't determine parents, will stop recursing here."
			elif [ "$VERBOSE" -le -1 ]
			then
				echo "$INDENT$DEV (parents missing)"
			else
				echo "$INDENT$DEV: Can't determine parents, will stop recursing here."
			fi
			continue
		fi

		local NUM_KEYS=0 NUM_DEV_TYPE=0 DEV_PARENTS=()
		while read KEY VALUE
		do
			case "$KEY" in
			"")
				# Try to ignore empty lines.
				[ -z "$VALUE" ] || die "Internal error: get-device-parents returned empty key with value \"$VALUE\""
				continue
				;;
			DEV_TYPE)
				: $[NUM_DEV_TYPE++]

				if [ "$VERBOSE" -ge 1 ]
				then
					echo "$INDENT* Type: $VALUE"
				elif [ "$VERBOSE" -le -1 ]
				then
					echo "$INDENT$DEV"
				else
					echo "$INDENT$DEV: $VALUE"
				fi
				;;
			PARENT)
				DEV_PARENTS=("${DEV_PARENTS[@]}" "$VALUE")
				;;
			*)
				die "Internal error: get-device-parents returned unrecognized key \"$KEY\" for device path \"$DEV\""
				;;
			esac
			: $[NUM_KEYS++]
		done <<<"$DEV_PARENTS_LINES"

		[ "$NUM_KEYS" -gt 0 ] || die "Internal error: get-device-parents gave no useable output for device path \"$DEV\""

		[ "$NUM_DEV_TYPE" -gt 0 ] || die "Internal error: get-device-parents omitted the DEV_TYPE key for device path \"$DEV\""

		if [ "$VERBOSE" -ge 1 ]
		then
			if [ "${#DEV_PARENTS[*]}" -gt 0 ]
			then
				echo "$INDENT* Found ${#DEV_PARENTS[*]} parent devices: ${DEV_PARENTS[*]}"
			else
				echo "$INDENT* Leaf device (no further parents), consider this the final backing storage."
			fi
		fi

		[ "${#DEV_PARENTS[*]}" -gt 0 ] && recurse-device-parents "$INDENT    " "${DEV_PARENTS[@]}"
	done

	return 0
}


VERBOSE=0

USAGE="cvnsnapper-plain-backingstorage show BTRFS_MOUNT_POINT"

while [ "$#" -gt 0 ] && [ "${1:0:1}" = "-" ]
do
	OPTION="$1"
	shift

	case "$OPTION" in
	--help|--usage|-\?)
		echo "Usage: $USAGE"
		exit 0
		;;
	-v)
		: $[VERBOSE++]
		;;
	-q)
		: $[VERBOSE--]
		;;
	*)
		die "Invalid option \"$OPTION\""
		;;
	esac
done

[ "$#" -ge 1 ] || die "Usage: $USAGE"

MODE="$1"
shift

case "$MODE" in
show)
	[ "$#" -eq 1 ] || die "Mode-of-operation \"$MODE\" takes exactly one argument, the mount point or block device to operate on"

	START_DEV="$1"
	shift

	recurse-device-parents "" "$START_DEV"

	exit
	;;
*)
	die "Invalid mode-of-operation \"$MODE\""
	;;
esac

exit 0
