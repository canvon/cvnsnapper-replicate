#!/usr/bin/perl

use strict;
use warnings;

(our $basename = $0) =~ s#^.*/##;

$SIG{'__WARN__'} = sub { warn("$basename: ", @_); };
$SIG{'__DIE__'}  = sub { die ("$basename: Fatal: ", @_) unless $^S; die(@_); };


sub parse_stat_record {
	my ($record_str) = scalar(@_) ? @_ : ($_);
	my $record = {
		record_str => $record_str,
	};

	die("Cannot extract record's file string\n")
	  unless ($record_str =~ /^  File: (.*?)\n/);
	my $file_str = $1;
	$record->{'file_str'} = $file_str;

	my $openquote  = qr/\xe2\x80\x98/;
	my $closequote = qr/\xe2\x80\x99/;
	if ($file_str =~ /^$openquote?(.*?)$closequote? -> $openquote?(.*?)$closequote?$/) {
		$record->{'file_path'} = $1;
		$record->{'symlink_target'} = $2;
	}
	elsif ($file_str =~ /^$openquote?(.*?)$closequote?$/) {
		$record->{'file_path'} = $1;
	}
	else {
		die("Cannot extract record file string's file path\n");
	}

	die("Cannot extract record's size/blocks/IO_block/type\n")
	  unless ($record_str =~ /^  Size: (\d+)\s+Blocks: (\d+)\s+IO Block: (\d+)\s+(.*?)$/m);
	@$record{'size', 'blocks', 'io_block', 'type'} = ($1, $2, $3, $4);

	die("Cannot extract record's device_str/inode/nlinks\n")
	  unless ($record_str =~ /^Device: (\S+)\s+Inode: (\d+)\s+Links: (\d+)$/m);
	@$record{'device_str', 'inode', 'nlinks'} = ($1, $2, $3);
	my $device_str = $record->{'device_str'};

	die("Cannot parse record's device_str\n")
	  unless ($device_str =~ /^([0-9a-f]+)h\/([0-9]+)d$/);
	my ($device_hex, $device_dec) = ($1, $2);
	@$record{'device_hex', 'device_dec'} = ($device_hex, $device_dec);

	die("Parse of record's device_hex \"$device_hex\" vs. device_dec \"$device_dec\" is inconsistent\n")
	  unless (hex($device_hex) == $device_dec);

	die("Cannot extract record's permissions/user/group\n")
	  unless ($record_str =~ /^Access: \((.*?)\)\s+Uid: \((.*?)\)\s+Gid: \((.*?)\)$/m);
	my ($perm_str, $uid_str, $gid_str) = ($1, $2, $3);
	@$record{'perm_str', 'uid_str', 'gid_str'} = ($perm_str, $uid_str, $gid_str);

	die("Cannot parse record's perm_str\n")
	  unless ($perm_str =~ /^\s*([0-7]+)\s*\/\s*([-a-z]+)\s*$/);
	@$record{'perm_oct', 'perm_long'} = ($1, $2);

	die("Cannot parse record's uid_str\n")
	  unless ($uid_str =~ /^\s*([0-9]+)\s*\/\s*(\S+)\s*$/);
	@$record{'uid', 'user'} = ($1, $2);

	die("Cannot parse record's gid_str\n")
	  unless ($gid_str =~ /^\s*([0-9]+)\s*\/\s*(\S+)\s*$/);
	@$record{'gid', 'group'} = ($1, $2);

	die("Cannot extract record's access time\n")
	  unless ($record_str =~ /^Access:\s+([0-9].*)$/m);
	$record->{'atime'} = $1;

	die("Cannot extract record's modification time\n")
	  unless ($record_str =~ /^Modify:\s+([0-9].*)$/m);
	$record->{'mtime'} = $1;

	die("Cannot extract record's status change time\n")
	  unless ($record_str =~ /^Change:\s+([0-9].*)$/m);
	$record->{'ctime'} = $1;

	die("Cannot extract record's birth time\n")
	  unless ($record_str =~ /^ Birth:\s+(-|[0-9].*)$/m);
	$record->{'btime'} = $1;

	return $record;
}

sub diff_stat_records {
	my ($ref_rec, $other_rec) = @_;
	my @diff_fields;

	my $compare_str = sub { $_[0] eq $_[1] };
	my $compare_num = sub { $_[0] == $_[1] };
	my $field_comparisons = [
		{ field_name => 'file_path',      comparison => $compare_str },
		{ field_name => 'symlink_target', comparison => $compare_str },
		{ field_name => 'size',           comparison => $compare_num },
		{ field_name => 'blocks',         comparison => $compare_num },
		{ field_name => 'io_blocks',      comparison => $compare_num },
		{ field_name => 'type',           comparison => $compare_str },
		{ field_name => 'device_dec',     comparison => $compare_num },
		{ field_name => 'inode',          comparison => $compare_num },
		{ field_name => 'nlinks',         comparison => $compare_num },
		{ field_name => 'perm_oct',       comparison => $compare_num },
		{ field_name => 'perm_long',      comparison => $compare_str },
		{ field_name => 'uid',            comparison => $compare_num },
		{ field_name => 'gid',            comparison => $compare_num },
		{ field_name => 'user',           comparison => $compare_str },
		{ field_name => 'group',          comparison => $compare_str },
		{ field_name => 'atime',          comparison => $compare_str },
		{ field_name => 'mtime',          comparison => $compare_str },
		{ field_name => 'ctime',          comparison => $compare_str },
		{ field_name => 'btime',          comparison => $compare_str },
	];

	foreach my $field_comparison (@$field_comparisons) {
		my ($field_name, $comparison) = @$field_comparison{'field_name', 'comparison'};

		if (exists($ref_rec->{$field_name}) && exists($other_rec->{$field_name})) {
			push(@diff_fields, $field_name)
			  unless ($comparison->($ref_rec->{$field_name}, $other_rec->{$field_name}));
		}
		elsif (exists($ref_rec->{$field_name}) xor exists($other_rec->{$field_name})) {
			push(@diff_fields, $field_name);
		}
	}

	return @diff_fields;
}

sub read_stat_records_from_fh {
	my ($fh) = @_;

	local $/ = undef;
	my $data = <$fh>;
	return split(/^(?=  File:)/m, $data);
}

sub read_stat_records_for_ctx {
	my ($ctx) = @_;

	my $base_path = $ctx->{'base_path'} or die("Internal error: context's base_path was not set");  # (no \n)
	my $stat_log_path = $base_path.".stat.log";
	$ctx->{'stat_log_path'} = $stat_log_path;

	open(my $stat_log_fh, '<', $stat_log_path) or die("Cannot open stat log at \"$stat_log_path\": $!\n");

	my @records = eval {
		map { parse_stat_record } (read_stat_records_from_fh($stat_log_fh));
	};
	if (scalar(@records) == 0 && $@) {
		die("Error processing stat log at \"$stat_log_path\": $@");  # (don't double the \n from $@)
	}
	$ctx->{'stat_records'} = \@records;

	close($stat_log_fh) or die("Cannot close stat log at \"$stat_log_path\": $!\n");

	return 1;
}

sub sort_stat_records {
	sort { $a->{'file_path'} cmp $b->{'file_path'} } (@_);
}

sub status_stat_recordss {
	my ($ref_records, $other_records) = @_;

	# TODO: Actually merge-compare the two sorted lists.
	print("Ref: ".scalar(@$ref_records).", Other: ".scalar(@$other_records)."\n");

	while (scalar(@$ref_records) >= 1 || scalar(@$other_records) >= 1) {
		if (scalar(@$ref_records) >= 1 && scalar(@$other_records) >= 1) {
			my $ref_rec   = $ref_records->[0];
			my $other_rec = $other_records->[0];

			my $comparison = $ref_rec->{'file_path'} cmp $other_rec->{'file_path'};
			if ($comparison == 0) {
				my $common_file_path = $other_rec->{'file_path'};

				# Compare details and output difference,
				# if some was found.
				my @diff_fields = eval {
					diff_stat_records($ref_rec, $other_rec);
				};
				if (scalar(@diff_fields) == 0 && $@) {
					warn("Warning: Problem diffing stat record for file path \"$common_file_path\": $@");  # (don't double the \n from $@)
					print("? $common_file_path\n");
				}
				elsif (scalar(@diff_fields)) {
					print(join(',', @diff_fields)." $common_file_path\n");
				}

				# shift from both
				shift(@$ref_records);
				shift(@$other_records);
			}
			elsif ($comparison < 0) {
				print("- ".$ref_rec->{'file_path'}."\n");
				shift(@$ref_records);
			}
			else {
				print("+ ".$other_rec->{'file_path'}."\n");
				shift(@$other_records);
			}
		}
		elsif (scalar(@$ref_records) >= 1) {
			print("- ".$ref_records->[0]{'file_path'}."\n");
			shift(@$ref_records);
		}
		else {
			print("+ ".$other_records->[0]{'file_path'}."\n");
			shift(@$other_records);
		}
	}

	return 0;
}


our $usage = "Usage: $0 DIFF_SUBVOL_WITH_INFIX SUBVOL_WITH_INFIX";

while (scalar(@ARGV) >= 1 && $ARGV[0] =~ /^-/) {
	my $opt = shift;
	for ($opt) {
		if (/^--(help|usage)$/) {
			print("$usage\n");
			exit(0);
		}
		else {
			die("Invalid option \"$opt\"\n");
		}
	}
}

scalar(@ARGV) == 2 or die("$usage\n");

my ($ref_base_path, $other_base_path) = @ARGV;

my $ref_ctx   = { base_path => $ref_base_path   };
my $other_ctx = { base_path => $other_base_path };

foreach my $ctx ($ref_ctx, $other_ctx) {
	my $result = eval {
		read_stat_records_for_ctx($ctx) or die("Read stat records for context was unsuccessful\n");
	};
	if (!defined($result) && $@) {
		die("Error read-processing subvolume meta-data base path ".$ctx->{'base_path'}.": $@");  # (don't double the \n from $@)
	}
}

my $result = eval {
	status_stat_recordss(
		[ sort_stat_records(@{$ref_ctx->{'stat_records'}}) ],
		[ sort_stat_records(@{$other_ctx->{'stat_records'}}) ]
	);
};
if (!defined($result) && $@) {
	die("Error status-processing subvolumes' stat records: $@"); # (don't double the \n from $@)
}

exit($result);
